<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
  <title>CloudFuze AI Assistant - Smart Cloud Migration Assistant</title>
  <meta name="description" content="Ask CloudFuze AI Assistant for migration-related queries and get instant, intelligent responses. Simplify cloud data migration with AI-powered assistance.">
  <meta name="keywords" content="AI Chat Agent, AI assistant, cloud migration chatbot, CloudFuze AI, migrate data with AI">
  <meta name="author" content="CloudFuze, Inc">
  <meta name="google-site-verification" content="PhjlsaI1LwJ0elVNYMvimmGx_a_PXGb6XQZZSRWsm10" />
  <meta name="robots" content="noindex, follow">
  
  <!-- Google Tag Manager -->
  <script>
    (function(w,d,s,l,i){
      w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});
      var f=d.getElementsByTagName(s)[0],
          j=d.createElement(s),
          dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;
      j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-K7XGC7N3');
  </script>
  <!-- End Google Tag Manager -->
  
  <!-- Open Graph -->
  <meta property="og:title" content="CloudFuze AI Assistant">
  <meta property="og:description" content="CloudFuze AI Assistant simplifies cloud migration by providing real-time AI-powered assistance, expert insights, and seamless solutions for businesses of all sizes.">
  <meta property="og:image" content="/CloudFuze-AI-og-Image.png">
  <meta property="og:url" content="https://ai.cloudfuze.com">
  <meta property="og:type" content="website">
  <meta property="article:published_time" content="2025-03-18T00:00:00Z">
  
  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="CloudFuze AI Assistant">
  <meta name="twitter:description" content="CloudFuze AI Assistant offers instant, AI-driven guidance for cloud migration. Get expert insights and solutions tailored for your business.">
  <meta name="twitter:image" content="/CloudFuze-AI-og-Image.png">
  <meta name="twitter:label1" content="Published on">
  <meta name="twitter:data1" content="March 18, 2025">
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://ai.cloudfuze.com" />
  
  <!-- Structured Data (Schema.org) -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "CloudFuze AI Assistant",
      "description": "CloudFuze AI Assistant offers instant, AI-driven guidance for cloud migration. Get expert insights and solutions tailored for your business.",
      "applicationCategory": "BusinessApplication",
      "operatingSystem": "Web",
      "url": "https://ai.cloudfuze.com",
      "image": "/CloudFuze-AI-og-Image.png",
      "datePublished": "2025-03-20",
      "dateModified": "2025-03-19",
      "publisher": {
        "@type": "Organization",
        "name": "CloudFuze",
        "url": "https://www.cloudfuze.com"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* Loading animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    html {
      scrollbar-gutter: stable;
    }

    body { 
      font-family: Arial, sans-serif; 
      background: white; 
      margin: 0; 
      padding: 0;
      min-height: 100vh;
      scroll-behavior: smooth;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: white;
      width: 100%;
      padding: 10px 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }

    header img {
      height: 40px;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .new-chat-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
      min-width: 100px;
    }

    .new-chat-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      color: #212529;
    }

    .new-chat-btn:active {
      background: #dee2e6;
      transform: translateY(1px);
    }

    .new-chat-btn.undo-mode {
      background: #dc3545;
      color: white;
      border-color: #dc3545;
      min-width: 100px;
    }

    .new-chat-btn.undo-mode:hover {
      background: #c82333;
      border-color: #bd2130;
    }

    .countdown-container {
      position: relative;
      margin-left: 4px;
      width: 24px;
      height: 20px;
    }

    .countdown-circle {
      width: 24px;
      height: 24px;
      position: absolute;
      top: -2px;
      left: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .countdown-circle svg {
      width: 24px;
      height: 24px;
      transform: rotate(-90deg);
      position: absolute;
      top: 0;
      left: 0;
    }

    .countdown-circle .progress-ring {
      fill: none;
      stroke-width: 2;
    }

    .countdown-circle .progress-ring-bg {
      stroke: rgba(255, 255, 255, 0.4);
    }

    .countdown-circle .progress-ring-fill {
      stroke: #fff;
      stroke-linecap: round;
      transition: stroke-dasharray 0.1s linear;
    }

    .countdown-text {
      font-size: 11px;
      font-weight: bold;
      color: white;
      position: absolute;
      z-index: 2;
      text-align: center;
      line-height: 1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .user-menu {
      position: relative;
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 20px;
      transition: background-color 0.3s ease;
    }

    .user-menu:hover {
      background-color: #f5f5f5;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background-color: #0129ac;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 14px;
    }

    .user-name {
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }

    .dropdown-arrow {
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid #666;
      margin-left: 4px;
    }

    .user-dropdown {
      position: absolute;
      top: 100%;
      right: 20px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      min-width: 200px;
      z-index: 1001;
      display: none;
      margin-top: 5px;
    }

    .user-dropdown.show {
      display: block;
    }

    .dropdown-item {
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background-color 0.2s ease;
    }

    .dropdown-item:last-child {
      border-bottom: none;
    }

    .dropdown-item:hover {
      background-color: #f5f5f5;
    }

    .dropdown-item.logout {
      color: #d32f2f;
    }

    .dropdown-item.logout:hover {
      background-color: #ffebee;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 80px; /* Space for fixed header */
      min-height: calc(100vh - 80px); /* Ensure content takes full height */
    }

    #messages {
      width: 60%;
      padding: 20px 10px 20px 10px;
      margin-bottom: 50px; /* Space for fixed footer */
      display: flex;
      flex-direction: column;
    }

    .message { 
      margin: 8px 0; 
      padding: 10px 15px; 
      border-radius: 20px; 
      width: fit-content; 
      max-width: 70%;
      word-wrap: break-word;
    }

    .user { 
      background: #e1ecff; 
      color: black; 
      margin-left: auto; 
      text-align: right; 
    }

    .bot { 
      background: white; 
      color: black; 
      margin-right: auto; 
      text-align: left; 
      position: relative;
      padding-bottom: 35px; /* Extra space for feedback buttons */
    }

    /* Thinking animation */
    .thinking {
      display: flex;
      align-items: center;
      gap: 8px;
      font-style: italic;
      color: #666;
    }

    .thinking-dots {
      display: inline-flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #666;
      animation: thinking-bounce 1.4s infinite ease-in-out both;
    }

    .thinking-dots span:nth-child(1) {
      animation-delay: -0.32s;
    }

    .thinking-dots span:nth-child(2) {
      animation-delay: -0.16s;
    }

    .thinking-dots span:nth-child(3) {
      animation-delay: 0s;
    }

    @keyframes thinking-bounce {
      0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Markdown styling for bot messages */
    .bot h1, .bot h2, .bot h3, .bot h4, .bot h5, .bot h6 {
      margin: 10px 0 5px 0;
      font-weight: bold;
    }
    
    .bot h1 { font-size: 1.5em; }
    .bot h2 { font-size: 1.3em; }
    .bot h3 { font-size: 1.1em; }
    
    .bot ul, .bot ol {
      margin: 10px 0;
      padding-left: 20px;
    }
    
    .bot li {
      margin: 5px 0;
    }
    
    .bot strong {
      font-weight: bold;
    }
    
    .bot em {
      font-style: italic;
    }
    
    .bot code {
      background-color: #f4f4f4;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }
    
    .bot pre {
      background-color: #f4f4f4;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      margin: 10px 0;
    }
    
    .bot pre code {
      background: none;
      padding: 0;
    }
    
    .bot blockquote {
      border-left: 4px solid #ddd;
      margin: 10px 0;
      padding-left: 15px;
      color: #666;
    }
    
    .bot a {
      color: #0066cc;
      text-decoration: underline;
    }
    
    .bot a:hover {
      color: #004499;
    }

    /* Copy button styles - ChatGPT style */
    .copy-button {
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 14px;
      color: #6e6e80;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
    }

    .copy-button:hover {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .copy-button.copied {
      background: #f4f4f4;
      color: #10a37f;
    }

    .message.bot {
      position: relative;
    }

    .message.bot .message-content {
      margin-bottom: 0;
    }

    /* Feedback buttons - ChatGPT style */
    .feedback-buttons {
      display: flex;
      gap: 4px;
      margin-top: -6px;
      align-items: center;
    }

    .feedback-btn {
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #6e6e80;
      width: 28px;
      height: 28px;
    }

    .feedback-btn:hover {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .feedback-btn.selected {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .feedback-btn.thumbs-up.selected {
      color: #10a37f;
    }

    .feedback-btn.thumbs-down.selected {
      color: #ef4444;
    }

    /* Icon styling - make all icons light grey */
    .copy-button img,
    .feedback-btn img {
      filter: brightness(0) saturate(100%) invert(60%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(90%) contrast(90%);
    }

    .copy-button:hover img,
    .feedback-btn:hover img {
      filter: brightness(0) saturate(100%) invert(20%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(100%) contrast(100%);
    }

    .feedback-btn.thumbs-up.selected img {
      filter: brightness(0) saturate(100%) invert(40%) sepia(100%) saturate(2000%) hue-rotate(90deg) brightness(90%) contrast(90%);
    }

    .feedback-btn.thumbs-down.selected img {
      filter: brightness(0) saturate(100%) invert(30%) sepia(100%) saturate(2000%) hue-rotate(0deg) brightness(90%) contrast(90%);
    }

    .feedback-text {
      font-size: 11px;
      color: #6c757d;
      margin-left: 4px;
    }

    /* Scroll to bottom button */
    #scroll-to-bottom-btn {
      position: fixed;
      bottom: 100px;
      right: 40px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: #0129ac;
      color: white;
      border: none;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(1, 41, 172, 0.3);
      transition: all 0.3s ease;
      z-index: 999;
    }

    #scroll-to-bottom-btn:hover {
      background: #0056b3;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(1, 41, 172, 0.4);
    }

    #scroll-to-bottom-btn:active {
      transform: translateY(0);
    }

    #scroll-to-bottom-btn.show {
      display: flex;
    }

    #scroll-to-bottom-btn svg {
      width: 24px;
      height: 24px;
      fill: currentColor;
    }

    #input-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: linear-gradient(to bottom, 
        rgba(255, 255, 255, 0) 0%, 
        rgba(255, 255, 255, 0.3) 10%, 
        rgba(255, 255, 255, 0.7) 40%, 
        rgba(255, 255, 255, 0.9) 70%, 
        rgba(255, 255, 255, 0.95) 100%);
      z-index: 1000;
    }

    .input-wrapper {
      width: 60%;
      max-width: 800px;
      display: flex;
      align-items: center;
      position: relative;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 25px;
      padding: 8px;
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.1),
        0 4px 12px rgba(0, 0, 0, 0.08),
        0 2px 6px rgba(0, 0, 0, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    #user-input {
      flex: 1;
      padding: 8px 50px 8px 15px;
      border-radius: 20px;
      border: none;
      outline: none;
      font-size: 16px;
      box-sizing: border-box;
      background: transparent;
      transition: all 0.2s ease;
    }

    #user-input:focus {
      background: rgba(255, 255, 255, 0.1);
    }

    #user-input::placeholder {
      color: rgba(0, 0, 0, 0.6);
    }

    #send-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      padding: 10px 15px;
      border: none;
      border-radius: 50px;
      background: #0129ac;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 
        0 4px 12px rgba(1, 41, 172, 0.3),
        0 2px 6px rgba(1, 41, 172, 0.2);
      transition: all 0.2s ease;
    }

    #send-btn svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
      stroke: currentColor;
    }

    #send-btn:hover {
      background: #0056b3;
      box-shadow: 
        0 6px 16px rgba(1, 41, 172, 0.4),
        0 3px 8px rgba(1, 41, 172, 0.3);
      transform: translateY(-50%) translateY(-0.5px);
    }

    #send-btn:active {
      transform: translateY(-50%) translateY(0.5px);
      box-shadow: 
        0 2px 8px rgba(1, 41, 172, 0.3),
        0 1px 4px rgba(1, 41, 172, 0.2);
    }
  </style>
  <link rel="icon" type="image/png" href="./images/CloudFuze-icon-64x64.png">
</head>
<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K7XGC7N3"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  
  <header>
    <img src="./images/CloudFuze Horizontal Logo.svg" alt="Logo">
    <div class="header-controls">
      <button class="new-chat-btn" id="newChatBtn">
        <span>
          <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
            <path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path>
          </svg>
        </span>
        <span>New Chat</span>
      </button>
      <div class="user-menu" id="userMenu">
      <div class="user-info">
        <div class="user-avatar" id="userAvatar">U</div>
        <span class="user-name" id="userName">User</span>
        <div class="dropdown-arrow"></div>
      </div>
        <div class="user-dropdown" id="userDropdown">
          <div class="dropdown-item" id="userEmail"></div>
          <div class="dropdown-item logout" id="logoutBtn">
            <span>
              <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
                <path d="M3.50171 12.6663V7.33333C3.50171 6.64424 3.50106 6.08728 3.53784 5.63704C3.57525 5.17925 3.65463 4.77342 3.84644 4.39681L3.96851 4.17806C4.2726 3.68235 4.70919 3.2785 5.23023 3.01302L5.3728 2.94661C5.7091 2.80238 6.06981 2.73717 6.47046 2.70443C6.9207 2.66764 7.47766 2.66829 8.16675 2.66829H9.16675L9.30054 2.68197C9.60367 2.7439 9.83179 3.0119 9.83179 3.33333C9.83179 3.65476 9.60367 3.92277 9.30054 3.9847L9.16675 3.99837H8.16675C7.45571 3.99837 6.96238 3.99926 6.57886 4.0306C6.297 4.05363 6.10737 4.09049 5.96362 4.14193L5.83374 4.19857C5.53148 4.35259 5.27861 4.58671 5.1023 4.87435L5.03198 5.00032C4.95147 5.15833 4.89472 5.36974 4.86401 5.74544C4.83268 6.12896 4.83179 6.6223 4.83179 7.33333V12.6663C4.83179 13.3772 4.8327 13.8707 4.86401 14.2542C4.8947 14.6298 4.95153 14.8414 5.03198 14.9993L5.1023 15.1263C5.27861 15.4137 5.53163 15.6482 5.83374 15.8021L5.96362 15.8577C6.1074 15.9092 6.29691 15.947 6.57886 15.9701C6.96238 16.0014 7.45571 16.0013 8.16675 16.0013H9.16675L9.30054 16.015C9.6036 16.0769 9.83163 16.345 9.83179 16.6663C9.83179 16.9877 9.60363 17.2558 9.30054 17.3177L9.16675 17.3314H8.16675C7.47766 17.3314 6.9207 17.332 6.47046 17.2952C6.06978 17.2625 5.70912 17.1973 5.3728 17.0531L5.23023 16.9867C4.70911 16.7211 4.27261 16.3174 3.96851 15.8216L3.84644 15.6038C3.65447 15.2271 3.57526 14.8206 3.53784 14.3626C3.50107 13.9124 3.50171 13.3553 3.50171 12.6663ZM13.8035 13.804C13.5438 14.0634 13.1226 14.0635 12.863 13.804C12.6033 13.5443 12.6033 13.1223 12.863 12.8626L13.8035 13.804ZM12.863 6.19661C13.0903 5.96939 13.4409 5.94126 13.699 6.11165L13.8035 6.19661L17.1375 9.52962C17.3969 9.78923 17.3968 10.2104 17.1375 10.4701L13.8035 13.804L13.3337 13.3333L12.863 12.8626L15.0603 10.6654H9.16675C8.79959 10.6654 8.50189 10.3674 8.50171 10.0003C8.50171 9.63306 8.79948 9.33529 9.16675 9.33529H15.0613L12.863 7.13704L12.7781 7.03255C12.6077 6.77449 12.6359 6.42386 12.863 6.19661Z"></path>
              </svg>
            </span>
            <span>Logout</span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <div class="main-content">
    <div id="messages"></div>
  </div>

  <!-- Scroll to bottom button -->
  <button id="scroll-to-bottom-btn" title="Scroll to bottom">
    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
      <path d="M9.33468 3.33333C9.33468 2.96617 9.6326 2.66847 9.99972 2.66829C10.367 2.66829 10.6648 2.96606 10.6648 3.33333V15.0609L15.363 10.3626L15.4675 10.2777C15.7255 10.1074 16.0762 10.1357 16.3034 10.3626C16.5631 10.6223 16.5631 11.0443 16.3034 11.304L10.4704 17.137C10.2108 17.3967 9.7897 17.3966 9.52999 17.137L3.69601 11.304L3.61105 11.1995C3.44054 10.9414 3.46874 10.5899 3.69601 10.3626C3.92328 10.1354 4.27479 10.1072 4.53292 10.2777L4.63741 10.3626L9.33468 15.0599V3.33333Z"></path>
    </svg>
  </button>

  <div id="input-container">
    <div class="input-wrapper">
      <input type="text" id="user-input" placeholder="Type your question...">
      <button id="send-btn">
        <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
          <path fill="none" d="M0 0h24v24H0z"></path>
          <path d="M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"></path>
        </svg>
      </button>
    </div>
  </div>

  <script>
    // API Base URL configuration
    function getApiBase() {
      const hostname = window.location.hostname;
      
      // Development environment
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://127.0.0.1:8002';
      }
      
      // Production environments
      if (hostname === 'ai.cloudfuze.com') {
        return 'https://ai.cloudfuze.com';
      }
      
      if (hostname === 'newcf3.cloudfuze.com') {
        return 'https://newcf3.cloudfuze.com';
      }
      
      // Default fallback - use current origin
      return window.location.origin;
    }

    const messagesDiv = document.getElementById("messages");
    const input = document.getElementById("user-input");
    const sendBtn = document.getElementById("send-btn");

    
    // Generate a session ID for conversation memory and Langfuse tracking
    let sessionId = localStorage.getItem('chatbot_session_id');
    if (!sessionId) {
      // Create readable session format: cf.conversation.YYYYMMDD.randomId
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const randomId = Math.random().toString(36).substr(2, 9);
      sessionId = `cf.conversation.${date}.${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      console.log('[SESSION] Created new session:', sessionId);
    }

    function addMessage(content, sender) {
      const div = document.createElement("div");
      div.className = "message " + sender;
      div.innerText = content;
      messagesDiv.appendChild(div);
      console.log(`[UI] Added ${sender} message. Total messages now: ${messagesDiv.children.length}`);
      scrollToBottom();
      return div;
    }

    function addMessageHTML(content, sender, traceId = null) {
      const div = document.createElement("div");
      div.className = "message " + sender;
      
      if (sender === "bot") {
        // For bot messages, wrap content and add copy button + feedback buttons
        div.innerHTML = `
          <div class="message-content">${content}</div>
          <div class="feedback-buttons">
            <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
              <img src="./images/copy-icon.svg?v=2" alt="Copy" width="16" height="16">
            </button>
            <button class="feedback-btn thumbs-up" onclick="submitFeedback(this, 'thumbs_up')" title="Good response">
              <img src="./images/thumbs-up-icon.svg?v=2" alt="Thumbs up" width="16" height="16">
            </button>
            <button class="feedback-btn thumbs-down" onclick="submitFeedback(this, 'thumbs_down')" title="Bad response">
              <img src="./images/thumbs-down-icon.svg?v=2" alt="Thumbs down" width="16" height="16">
            </button>
            <span class="feedback-text"></span>
          </div>
        `;
        
        // Store trace_id if provided
        if (traceId) {
          div.dataset.traceId = traceId;
        }
      } else {
        // For user messages, keep as is
        div.innerHTML = content;
      }
      
      messagesDiv.appendChild(div);
      console.log(`[UI] Added ${sender} message HTML. Total messages now: ${messagesDiv.children.length}`);
      scrollToBottom();
      return div;
    }

    function renderMarkdown(text) {
      if (typeof marked !== 'undefined') {
        return marked.parse(text);
      } else {
        // Fallback: basic markdown-like formatting
        return text
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.*?)\*/g, '<em>$1</em>')
          .replace(/`(.*?)`/g, '<code>$1</code>')
          .replace(/^### (.*$)/gim, '<h3>$1</h3>')
          .replace(/^## (.*$)/gim, '<h2>$1</h2>')
          .replace(/^# (.*$)/gim, '<h1>$1</h1>')
          .replace(/^\* (.*$)/gim, '<li>$1</li>')
          .replace(/^\d+\. (.*$)/gim, '<li>$1</li>')
          .replace(/\n/g, '<br>');
      }
    }

    // Scroll mode state management
    let scrollMode = 'auto'; // 'auto' or 'manual'
    let isStreaming = false; // Track if bot is currently streaming
    let userInteractionTimeout = null; // Debounce user interaction detection
    const scrollToBottomBtn = document.getElementById('scroll-to-bottom-btn');
    
    // Update button visibility based on mode
    function updateButtonVisibility() {
      if (scrollMode === 'manual') {
        scrollToBottomBtn.classList.add('show');
      } else {
        scrollToBottomBtn.classList.remove('show');
      }
    }
    
    function scrollToBottom() {
      // Only auto-scroll if in auto mode
      if (scrollMode !== 'auto') {
        console.log('[SCROLL] Skipping auto-scroll - in MANUAL mode');
        return;
      }
      
      // Use requestAnimationFrame to ensure DOM is updated before scrolling
      requestAnimationFrame(() => {
        // Scroll to the very bottom of the page
        window.scrollTo({
          top: document.body.scrollHeight,
          behavior: 'smooth' // Use smooth for better UX
        });
      });
    }
    
    // Check if user is at the bottom of the page
    function isAtBottom() {
      const scrollThreshold = 100; // pixels from bottom to be considered "at bottom"
      const atBottom = (window.innerHeight + window.scrollY) >= (document.body.scrollHeight - scrollThreshold);
      return atBottom;
    }
    
    // Handle user wheel/scroll gestures (actual user interaction)
    function handleUserScrollGesture(event) {
      // Only care if we're in auto mode (manual mode already stops scrolling)
      if (scrollMode !== 'auto') {
        return;
      }
      
      console.log('[SCROLL] User gesture detected, deltaY:', event.deltaY);
      
      // Check if user is scrolling up (negative deltaY)
      const scrollingUp = event.deltaY < 0;
      
      if (scrollingUp) {
        // User is trying to scroll up - switch to manual mode
        scrollMode = 'manual';
        updateButtonVisibility();
        console.log('[SCROLL] ‚ö†Ô∏è Switched to MANUAL mode - user scrolled up');
      }
    }
    
    // Handle touch scrolling on mobile
    let touchStartY = 0;
    function handleTouchStart(event) {
      if (event.touches.length > 0) {
        touchStartY = event.touches[0].clientY;
      }
    }
    
    function handleTouchMove(event) {
      if (scrollMode !== 'auto') {
        return;
      }
      
      if (event.touches.length > 0) {
        const touchEndY = event.touches[0].clientY;
        const deltaY = touchEndY - touchStartY;
        
        // Scrolling up has positive deltaY (finger moves down)
        if (deltaY > 10) {
          scrollMode = 'manual';
          updateButtonVisibility();
          console.log('[SCROLL] ‚ö†Ô∏è Switched to MANUAL mode - touch scroll up');
        }
      }
    }
    
    // Monitor scroll position to switch back to auto when at bottom
    function checkScrollPosition() {
      // Check if we're in manual mode and user scrolled to bottom
      // (works during streaming AND after streaming ends)
      if (scrollMode === 'manual' && isAtBottom()) {
        // User manually scrolled back to bottom - switch to auto
        scrollMode = 'auto';
        updateButtonVisibility();
        console.log('[SCROLL] ‚úì Switched to AUTO mode - user reached bottom');
      }
    }
    
    // Handle scroll to bottom button click
    function handleScrollToBottomClick() {
      console.log('[SCROLL] üîò Button clicked - switching to AUTO mode');
      scrollMode = 'auto';
      updateButtonVisibility();
      window.scrollTo({
        top: document.body.scrollHeight,
        behavior: 'smooth'
      });
    }
    
    // Add event listeners for user scroll gestures
    window.addEventListener('wheel', handleUserScrollGesture, { passive: true });
    window.addEventListener('touchstart', handleTouchStart, { passive: true });
    window.addEventListener('touchmove', handleTouchMove, { passive: true });
    
    // Check scroll position periodically to switch back to auto mode
    window.addEventListener('scroll', checkScrollPosition, { passive: true });
    
    // Add click event listener to scroll button
    scrollToBottomBtn.addEventListener('click', handleScrollToBottomClick);

    // Submit feedback functionality
    async function submitFeedback(button, rating) {
      try {
        const messageDiv = button.closest('.message.bot');
        const traceId = messageDiv.dataset.traceId || messageDiv.dataset.traceid;
        
        // Check if feedback already submitted
        if (messageDiv.dataset.feedbackSubmitted === 'true') {
          console.log('Feedback already submitted for this message');
          return;
        }
        
        // Disable all feedback buttons immediately to prevent double-clicking
        const feedbackButtons = messageDiv.querySelectorAll('.feedback-btn');
        feedbackButtons.forEach(btn => {
          btn.disabled = true;
          btn.style.cursor = 'not-allowed';
          btn.style.opacity = '0.5';
        });
        
        let finalTraceId = traceId;
        if (!traceId) {
          // Generate a fallback trace_id for this specific message
          const fallbackTraceId = 'feedback_fallback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          messageDiv.dataset.traceId = fallbackTraceId;
          finalTraceId = fallbackTraceId;
        }
        
        const apiBase = getApiBase();
        
        // Get current user for auth token
        const currentUser = JSON.parse(localStorage.getItem('user') || 'null');
        if (!currentUser || !currentUser.access_token) {
          console.error('[FEEDBACK] User not authenticated');
          return;
        }
        
        // Send feedback to backend
        const response = await fetch(`${apiBase}/feedback`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Authorization": `Bearer ${currentUser.access_token}`
          },
          body: JSON.stringify({
            trace_id: finalTraceId,
            rating: rating,
            comment: ""
          }),
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log("Feedback submitted:", data);
          
          // Mark as submitted to prevent future submissions
          messageDiv.dataset.feedbackSubmitted = 'true';
          
          // Update UI to show which button was clicked
          feedbackButtons.forEach(btn => btn.classList.remove('selected'));
          button.classList.add('selected');
          
          // Show feedback text
          const feedbackText = messageDiv.querySelector('.feedback-text');
          feedbackText.textContent = rating === 'thumbs_up' ? 'Thanks for your feedback!' : 'Thanks! We\'ll improve.';
          
          // Clear feedback text after 3 seconds
          setTimeout(() => {
            feedbackText.textContent = '';
          }, 3000);
          
        } else {
          console.error("Failed to submit feedback");
          
          // Re-enable buttons on error so user can retry
          feedbackButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.cursor = 'pointer';
            btn.style.opacity = '1';
          });
          
          // Show error message
          const feedbackText = messageDiv.querySelector('.feedback-text');
          feedbackText.textContent = 'Failed to submit. Try again.';
          feedbackText.style.color = '#dc3545';
          
          setTimeout(() => {
            feedbackText.textContent = '';
            feedbackText.style.color = '';
          }, 3000);
        }
        
      } catch (error) {
        console.error("Error submitting feedback:", error);
        
        // Re-enable buttons on error so user can retry
        const messageDiv = button.closest('.message.bot');
        const feedbackButtons = messageDiv.querySelectorAll('.feedback-btn');
        feedbackButtons.forEach(btn => {
          btn.disabled = false;
          btn.style.cursor = 'pointer';
          btn.style.opacity = '1';
        });
        
        // Show error message
        const feedbackText = messageDiv.querySelector('.feedback-text');
        if (feedbackText) {
          feedbackText.textContent = 'Error occurred. Try again.';
          feedbackText.style.color = '#dc3545';
          
          setTimeout(() => {
            feedbackText.textContent = '';
            feedbackText.style.color = '';
          }, 3000);
        }
      }
    }

    // Copy message functionality
    async function copyMessage(button) {
      try {
        // Get the message content (text only, without HTML)
        const messageDiv = button.closest('.message.bot');
        const contentDiv = messageDiv.querySelector('.message-content');
        
        // Extract text content from the HTML
        const textContent = contentDiv.textContent || contentDiv.innerText || '';
        
        // Copy to clipboard
        await navigator.clipboard.writeText(textContent);
        
        // Show success feedback
        const originalHTML = button.innerHTML;
        button.innerHTML = '<span style="color: #10a37f;">‚úì</span>';
        button.classList.add('copied');
        
        // Reset after 2 seconds
        setTimeout(() => {
          button.innerHTML = originalHTML;
          button.classList.remove('copied');
        }, 2000);
        
      } catch (err) {
        console.error('Failed to copy text: ', err);
        
        // Fallback: show error feedback
        const originalHTML = button.innerHTML;
        button.innerHTML = '<span style="color: #721c24;">‚ùå</span>';
        button.style.background = '#f8d7da';
        
        // Reset after 2 seconds
        setTimeout(() => {
          button.innerHTML = originalHTML;
          button.style.background = '';
        }, 2000);
      }
    }

    async function sendMessage() {
      const question = input.value.trim();
      if (!question) return;

      addMessage(question, "user");
      input.value = "";

      // Show thinking animation (addMessageHTML will scroll automatically)
      const botDiv = addMessageHTML("", "bot");
      botDiv.innerHTML = `
        <div class="thinking">
          Thinking
          <span class="thinking-dots">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
      `;

      // Force another scroll to ensure thinking is visible
      setTimeout(() => scrollToBottom(), 50);

      // Start streaming - enable scroll tracking
      isStreaming = true;
      scrollMode = 'auto'; // Reset to auto mode for new message
      updateButtonVisibility(); // Ensure button is hidden in auto mode
      console.log('[SCROLL] Started streaming - mode set to AUTO');

      try {
        console.log("[CHAT] Sending question:", question);
        console.log("[CHAT] User ID:", currentUser ? currentUser.id : "Not logged in");
        console.log("[CHAT] Current messages in UI:", messagesDiv.children.length);
        
        // Check if user is authenticated
        if (!currentUser || !currentUser.access_token) {
          console.error("[CHAT] User not authenticated, redirecting to login");
          localStorage.removeItem('user');
          window.location.href = "login.html";
          return;
        }
        
        const requestBody = { question };
        
        // ALWAYS send session_id for session continuity in Langfuse
        requestBody.session_id = sessionId;
        
        console.log("[CHAT] Request body:", requestBody);
        
        // Use streaming endpoint for real-time responses
        // IMPORTANT: Send Authorization header with access token
        const response = await fetch(`${getApiBase()}/chat/stream`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Authorization": `Bearer ${currentUser.access_token}`
          },
          body: JSON.stringify(requestBody),
        });

        console.log("Response status:", response.status);
        
        // Handle authentication errors
        if (response.status === 401 || response.status === 403) {
          console.error("[CHAT] Authentication failed, redirecting to login");
          localStorage.removeItem('user');
          window.location.href = "login.html";
          return;
        }
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Keep thinking animation until we get thinking_complete signal
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let fullResponse = "";
        let lastRenderTime = 0;
        const renderThrottle = 16; // 60fps - re-render every 16ms for smooth streaming

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ""; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                if (data.type === 'thinking_complete') {
                  // Clear thinking animation and prepare for streaming (NO BUTTONS YET)
                  botDiv.innerHTML = `<div class="message-content"></div>`;
                  console.log("Thinking complete, starting streaming...");
                } else if (data.type === 'sources') {
                  // Log source information to browser console
                  console.log("[CONSOLE]", data.sources);
                } else if (data.type === 'token') {
                  // Add token to response (STILL NO BUTTONS)
                  const token = data.token;
                  fullResponse += token;
                  
                  // Throttle rendering to improve performance
                  const now = Date.now();
                  if (now - lastRenderTime > renderThrottle) {
                    // Render markdown and update only the message content
                    const contentDiv = botDiv.querySelector('.message-content');
                    if (contentDiv) {
                      contentDiv.innerHTML = renderMarkdown(fullResponse);
                    } else {
                      // Fallback: create content div only
                      botDiv.innerHTML = `<div class="message-content">${renderMarkdown(fullResponse)}</div>`;
                    }
                    scrollToBottom();
                    lastRenderTime = now;
                  }
                } else if (data.type === 'done') {
                  // Final response received with trace_id
                  fullResponse = data.full_response || fullResponse;
                  const traceId = data.trace_id;
                  
                  console.log("Done received. Full response length:", fullResponse.length);
                  
                  // Check if response is empty
                  if (!fullResponse || fullResponse.trim() === '') {
                    console.error("‚ö†Ô∏è Empty response received!");
                    fullResponse = "I apologize, but I wasn't able to generate a response. Please try again.";
                  }
                  
                  // Final render with complete response and buttons
                  botDiv.innerHTML = `
                    <div class="message-content">${renderMarkdown(fullResponse)}</div>
                    <div class="feedback-buttons">
                      <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                        <img src="./images/copy-icon.svg?v=2" alt="Copy" width="16" height="16">
                      </button>
                      <button class="feedback-btn thumbs-up" onclick="submitFeedback(this, 'thumbs_up')" title="Good response">
                        <img src="./images/thumbs-up-icon.svg?v=2" alt="Thumbs up" width="16" height="16">
                      </button>
                      <button class="feedback-btn thumbs-down" onclick="submitFeedback(this, 'thumbs_down')" title="Bad response">
                        <img src="./images/thumbs-down-icon.svg?v=2" alt="Thumbs down" width="16" height="16">
                      </button>
                      <span class="feedback-text"></span>
                    </div>
                  `;
                  
                  // Store trace_id on the bot message for feedback
                  if (traceId) {
                    botDiv.dataset.traceId = traceId;
                  } else {
                    // Generate a fallback trace_id for feedback functionality
                    const fallbackTraceId = 'fallback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    botDiv.dataset.traceId = fallbackTraceId;
                  }
                  
                  console.log("[CHAT] Streaming complete, trace_id:", traceId);
                  console.log("[CHAT] Total messages in UI now:", messagesDiv.children.length);
                  
                  // End streaming - keep current mode (don't force to auto)
                  isStreaming = false;
                  // Don't change scrollMode here - keep user's preference (manual or auto)
                  console.log('[SCROLL] Streaming ended - keeping current mode:', scrollMode);
                  
                  return;
                } else if (data.type === 'error') {
                  throw new Error(data.error);
                }
              } catch (e) {
                console.error("Error parsing streaming data:", e);
              }
            }
          }
        }
        
      } catch (error) {
        console.error("Error sending message:", error);
        // Clear thinking animation and show error
        botDiv.innerHTML = "Sorry, there was an error. Please try again.";
        
        // End streaming on error - keep current mode
        isStreaming = false;
        console.log('[SCROLL] Error occurred - keeping current mode:', scrollMode);
      }
    }







    sendBtn.addEventListener("click", sendMessage);
    input.addEventListener("keypress", (e) => { if (e.key === "Enter") sendMessage(); });

    // Add a function to start a new conversation (clear memory)
    async function startNewConversation() {
      console.log('[NEW_CHAT] Starting new conversation - clearing messages');
      if (currentUser && currentUser.id && currentUser.access_token) {
        // Clear user's chat history on server
        try {
          await fetch(`${getApiBase()}/chat/history/${currentUser.id}`, {
            method: "DELETE",
            headers: {
              'Authorization': `Bearer ${currentUser.access_token}`
            }
          });
        } catch (error) {
          console.error('Failed to clear chat history:', error);
        }
      }
      
      // Create new session for new conversation
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const randomId = Math.random().toString(36).substr(2, 9);
      sessionId = `cf.conversation.${date}.${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      messagesDiv.innerHTML = '';
      console.log('[NEW_CHAT] Messages cleared. New session:', sessionId, 'Total messages now: 0');
    }

    // Variables for undo functionality
    let chatBackup = null;
    let undoTimeout = null;
    let isUndoMode = false;

    // Handle new chat button click
    async function handleNewChat() {
      const button = document.getElementById('newChatBtn');
      
      if (!isUndoMode) {
        // Store current chat before clearing
        chatBackup = {
          messages: Array.from(messagesDiv.children).map(msg => ({
            className: msg.className,
            innerHTML: msg.innerHTML
          })),
          sessionId: sessionId
        };
        
        // Clear the messages display
        console.log('[NEW_CHAT] Clearing messages for undo feature');
        messagesDiv.innerHTML = '';
        
        // Change button to undo mode
        button.innerHTML = '<span><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path></svg></span><span>Undo</span><div class="countdown-container"><div class="countdown-circle" id="countdownCircle"></div></div>';
        button.classList.add('undo-mode');
        isUndoMode = true;
        
        // Initialize countdown circle
        initializeCountdownCircle();
        
        // Start countdown
        startUndoCountdown();
      } else {
        // Restore chat
        restoreChat();
      }
    }

    // Initialize countdown circle
    function initializeCountdownCircle() {
      const circle = document.getElementById('countdownCircle');
      const radius = 10; // radius of the circle (increased from 8)
      const circumference = 2 * Math.PI * radius;
      
      // Create SVG circle - start with full circle (offset = 0)
      circle.innerHTML = `
        <svg width="24" height="24">
          <circle class="progress-ring progress-ring-bg" cx="12" cy="12" r="${radius}"></circle>
          <circle class="progress-ring progress-ring-fill" cx="12" cy="12" r="${radius}" 
                  stroke-dasharray="${circumference}" 
                  stroke-dashoffset="0"></circle>
        </svg>
        <span class="countdown-text" id="countdownText">3</span>
      `;
      
      // Store circumference for animation
      circle.dataset.circumference = circumference;
    }

    // Start undo countdown
    function startUndoCountdown() {
      const textElement = document.getElementById('countdownText');
      const circle = document.getElementById('countdownCircle');
      const circumference = parseFloat(circle.dataset.circumference);
      
      const startTime = Date.now();
      const duration = 3000; // 3 seconds in milliseconds
      
      const updateCountdown = () => {
        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, duration - elapsed);
        const countdown = Math.ceil(remaining / 1000);
        
        // Update text (always white)
        textElement.textContent = countdown;
        textElement.style.color = 'white';
        
        // Update circle progress - smooth animation
        const progress = remaining / duration; // This goes from 1.0 to 0.0
        const offset = circumference - (progress * circumference);
        const fillCircle = circle.querySelector('.progress-ring-fill');
        fillCircle.style.strokeDashoffset = offset;
        
        // Keep circle white always
        fillCircle.style.stroke = '#fff';
        
        if (remaining > 0) {
          undoTimeout = requestAnimationFrame(updateCountdown);
        } else {
          // Time's up - permanently delete chat
          permanentlyDeleteChat();
        }
      };
      
      updateCountdown();
    }

    // Restore chat from backup
    function restoreChat() {
      if (chatBackup) {
        // Restore messages
        messagesDiv.innerHTML = '';
        chatBackup.messages.forEach(msgData => {
          const msgDiv = document.createElement('div');
          msgDiv.className = msgData.className;
          msgDiv.innerHTML = msgData.innerHTML;
          messagesDiv.appendChild(msgDiv);
        });
        
        // Add copy buttons to any bot messages that don't have them
        const botMessages = messagesDiv.querySelectorAll('.message.bot');
        botMessages.forEach(msgDiv => {
          if (!msgDiv.querySelector('.copy-button')) {
            const textContent = msgDiv.textContent || msgDiv.innerText || '';
            if (textContent.trim()) {
              msgDiv.innerHTML = `
                <div class="message-content">${msgDiv.innerHTML}</div>
                <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                  <img src="./images/copy-icon.svg?v=2" alt="Copy" width="16" height="16">
                </button>
              `;
            }
          }
        });
        
        // Restore session
        sessionId = chatBackup.sessionId;
        localStorage.setItem('chatbot_session_id', sessionId);
        
        // Scroll to bottom after restoring messages
        scrollToBottom();
        
        // Clear backup
        chatBackup = null;
      }
      
      // Reset button
      resetNewChatButton();
    }

    // Permanently delete chat
    async function permanentlyDeleteChat() {
      if (currentUser && currentUser.id && currentUser.access_token) {
        // Clear user's chat history on server
        try {
          await fetch(`${getApiBase()}/chat/history/${currentUser.id}`, {
            method: "DELETE",
            headers: {
              'Authorization': `Bearer ${currentUser.access_token}`
            }
          });
        } catch (error) {
          console.error('Failed to clear chat history:', error);
        }
      }
      
      // Create new session for new conversation
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const randomId = Math.random().toString(36).substr(2, 9);
      sessionId = `cf.conversation.${date}.${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      console.log('[UNDO_CONFIRM] New session created:', sessionId);
      
      // Clear backup
      chatBackup = null;
      
      // Reset button
      resetNewChatButton();
    }

    // Reset new chat button to normal state
    function resetNewChatButton() {
      const button = document.getElementById('newChatBtn');
      button.innerHTML = '<span><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path></svg></span><span>New Chat</span>';
      button.classList.remove('undo-mode');
      isUndoMode = false;
      
      if (undoTimeout) {
        cancelAnimationFrame(undoTimeout);
        undoTimeout = null;
      }
    }

    // Double-click to start new conversation removed to prevent accidental chat clearing

    // Polyfill for POST EventSource
    class EventSourcePolyfill {
      constructor(url, options) {
        const { method, headers, body } = options;
        this._url = url;
        this._method = method || "GET";
        this._headers = headers || {};
        this._body = body || null;
        this.onmessage = null;
        this.onerror = null;
        this._start();
      }

      async _start() {
        const response = await fetch(this._url, {
          method: this._method,
          headers: this._headers,
          body: this._body,
        });
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const parts = buffer.split("\n\n");
          buffer = parts.pop();
          for (const part of parts) {
            if (part.startsWith("data: ")) {
              const data = part.replace("data: ", "");
              if (this.onmessage) this.onmessage({ data });
            }
          }
        }
      }

      close() {}
    }

    // User authentication functionality
    let currentUser = null;

    // Handle OAuth callback
    function handleOAuthCallback() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      const error = urlParams.get('error');

      if (error) {
        alert('Microsoft login failed: ' + error);
        return;
      }

      if (code) {
        exchangeCodeForToken(code);
      }
    }

    // Exchange authorization code for access token
    async function exchangeCodeForToken(code) {
      // Get code verifier from session storage
      const codeVerifier = sessionStorage.getItem('code_verifier');
      
      if (!codeVerifier) {
        /*alert('Login failed: Code verifier not found');*/
        window.location.href = "login.html";
        return;
      }
      
      try {
        const requestBody = {
          code: code,
          redirect_uri: window.location.origin + "/index.html",
          code_verifier: codeVerifier
        };
        
        const response = await fetch(`${getApiBase()}/auth/microsoft/callback`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        if (response.ok) {
          const data = await response.json();
          console.log('[AUTH] Received user data from backend:', data);
          
          // Clear code verifier from session storage
          sessionStorage.removeItem('code_verifier');
          
          const user = {
            id: data.user_id,
            name: data.name,
            email: data.email,
            access_token: data.access_token,
            refresh_token: data.refresh_token
          };
          
          console.log('[AUTH] Created user object:', user);
          
          // Extra frontend validation: Check CloudFuze domain
          if (!user.email || !user.email.endsWith('@cloudfuze.com')) {
            console.error('[AUTH] Non-CloudFuze email attempted to log in:', user.email);
            hideLoadingIndicator();
            sessionStorage.clear();
            localStorage.removeItem('user');
            // Redirect to login with error parameter
            window.location.href = `login.html?error=unauthorized_domain&email=${encodeURIComponent(user.email || 'Unknown')}`;
            return;
          }
          
          localStorage.setItem('user', JSON.stringify(user));
          
          // Clear URL parameters
          window.history.replaceState({}, document.title, window.location.pathname);
          
          // Initialize with new user
          currentUser = user;
          updateUserInfo(user);
          
          // Only load history if user.id is valid
          if (user.id) {
            loadUserChatHistory(user.id).catch(error => {
              console.error('[ERROR] Failed to load history:', error);
            });
          } else {
            console.warn('[WARNING] User ID is undefined, skipping history load');
          }
          
          hideLoadingIndicator();
        } else {
          const errorText = await response.text();
          try {
            const errorJson = JSON.parse(errorText);
            if (errorJson.error === "Access denied") {
              alert('Access Denied: ' + errorJson.message + '\n\nPlease use your CloudFuze company account to access this application.');
            } else {
              alert('Login failed: ' + (errorJson.error || errorText || 'Unknown error'));
            }
          } catch (e) {
            alert('Login failed: ' + (errorText || 'Unknown error'));
          }
          hideLoadingIndicator();
          window.location.href = "login.html";
        }
        } catch (error) {
          hideLoadingIndicator();
          alert('Login failed: ' + error.message);
          window.location.href = "login.html";
        }
    }

    // Initialize authentication
    function initAuth() {
      // Check for OAuth callback first
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      
      if (code) {
        // We have an OAuth callback, handle it first
        showLoadingIndicator("Authenticating...");
        handleOAuthCallback();
        return; // Don't check for existing user, let the callback handle it
      }
      
      // Check if user is logged in (only if no OAuth callback)
      const user = JSON.parse(localStorage.getItem('user') || 'null');
      
      console.log('[AUTH] Retrieved user from localStorage:', user);
      
      if (!user || !user.access_token) {
        console.log('[AUTH] No user or access token found, redirecting to login');
        window.location.href = "login.html";
        return;
      }

      // Verify token is still valid AND check domain
      showLoadingIndicator("Verifying access...");
      verifyToken(user.access_token).then(result => {
        if (result.isValid) {
          currentUser = user;
          updateUserInfo(user);
          console.log('[AUTH] User authenticated, loading history for user.id:', user.id);
          
          // Always load history, even if it fails (but only if user.id exists)
          if (user.id) {
            loadUserChatHistory(user.id).catch(error => {
              console.error('[ERROR] Failed to load history, but continuing:', error);
            }).finally(() => {
              hideLoadingIndicator();
            });
          } else {
            console.warn('[WARNING] User ID is undefined, skipping history load');
            hideLoadingIndicator();
          }
        } else {
          // Handle different failure reasons
          hideLoadingIndicator();
          
          // Clear invalid user data
          localStorage.removeItem('user');
          currentUser = null;
          
          // Redirect to login with appropriate error parameter
          if (result.reason === 'unauthorized_domain') {
            window.location.href = `login.html?error=unauthorized_domain&email=${encodeURIComponent(result.email || 'Unknown')}`;
          } else if (result.reason === 'invalid_token') {
            window.location.href = "login.html?error=session_expired";
          } else {
            console.log('[AUTH] Token verification failed, redirecting to login');
            window.location.href = "login.html?error=verification_failed";
          }
        }
      }).catch(error => {
        console.error('[ERROR] Token verification failed:', error);
        hideLoadingIndicator();
        // Don't allow app access if verification fails
        localStorage.removeItem('user');
        currentUser = null;
        window.location.href = "login.html?error=verification_failed";
      });
    }

    // Verify Microsoft access token
    async function verifyToken(accessToken) {
      try {
        const response = await fetch('https://graph.microsoft.com/v1.0/me', {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        });
        
        if (!response.ok) {
          return { isValid: false, reason: 'invalid_token' };
        }
        
        const userInfo = await response.json();
        const userEmail = userInfo.mail || userInfo.userPrincipalName || '';
        
        // Check if email is from CloudFuze domain
        if (!userEmail.endsWith('@cloudfuze.com')) {
          console.error('[AUTH] Access denied for non-CloudFuze email:', userEmail);
          return { isValid: false, reason: 'unauthorized_domain', email: userEmail };
        }
        
        return { isValid: true, email: userEmail };
      } catch (error) {
        console.error('[AUTH] Token verification failed:', error);
        return { isValid: false, reason: 'verification_failed' };
      }
    }

    // Update user info in header
    function updateUserInfo(user) {
      const userName = document.getElementById('userName');
      const userAvatar = document.getElementById('userAvatar');
      const userEmail = document.getElementById('userEmail');
      
      if (user) {
        userName.textContent = user.name || 'User';
        userAvatar.textContent = (user.name || 'U').charAt(0).toUpperCase();
        userEmail.textContent = user.email || '';
      } else {
        userName.textContent = 'User';
        userAvatar.textContent = 'U';
        userEmail.textContent = '';
      }
    }

    // Handle dropdown toggle
    function toggleDropdown() {
      const dropdown = document.getElementById('userDropdown');
      dropdown.classList.toggle('show');
    }

    // Close dropdown when clicking outside
    function closeDropdown(event) {
      const userMenu = document.getElementById('userMenu');
      const dropdown = document.getElementById('userDropdown');
      
      if (!userMenu.contains(event.target)) {
        dropdown.classList.remove('show');
      }
    }

    // Load user's chat history
    async function loadUserChatHistory(userId) {
      try {
        console.log('[HISTORY] Loading chat history for user:', userId);
        
        // Check if userId is valid
        if (!userId || userId === 'undefined' || userId === 'null') {
          console.error('[HISTORY] Invalid user ID:', userId);
          return;
        }
        
        // Get current user for auth token
        const currentUser = JSON.parse(localStorage.getItem('user') || 'null');
        if (!currentUser || !currentUser.access_token) {
          console.error('[HISTORY] User not authenticated');
          return;
        }
        
        const response = await fetch(`${getApiBase()}/chat/history/${userId}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${currentUser.access_token}`
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          const history = data.history || [];
          console.log('[HISTORY] Loaded', history.length, 'messages from server');
          
          // Only clear if we have history to show
          if (history.length > 0) {
            // Clear existing messages
            messagesDiv.innerHTML = '';
            
            // Load chat history
            for (const message of history) {
              const sender = message.role === 'user' ? 'user' : 'bot';
              if (sender === 'bot') {
                // Render markdown for bot messages with copy button and feedback buttons
                // Note: Historical messages won't have trace_id, so feedback won't work for them
                addMessageHTML(renderMarkdown(message.content), sender, null);
              } else {
                // Keep plain text for user messages
                addMessage(message.content, sender);
              }
            }
            
            console.log('[HISTORY] Displayed', history.length, 'messages in UI');
            // Scroll to bottom
            scrollToBottom();
          } else {
            console.log('[HISTORY] No history to load (empty chat)');
          }
        } else {
          console.error('[HISTORY] Failed to load, status:', response.status);
          const errorText = await response.text();
          console.error('[HISTORY] Error details:', errorText);
        }
      } catch (error) {
        console.error('[HISTORY] Failed to load chat history:', error);
        console.error('[HISTORY] Error details:', error.message, error.stack);
        // Continue with empty chat if loading fails
      }
    }

    // Handle logout
    function handleLogout() {
      try {
        
  



        // Clear user data from localStorage
        localStorage.removeItem('user');
        currentUser = null;
        
        // Redirect to login page
        window.location.href = "login.html";
      } catch (error) {
        console.error('Logout failed:', error);
        alert('Logout failed: ' + error.message);
      }
    }

    // Initialize when page loads
    // Show loading indicator
    function showLoadingIndicator(message) {
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'loading-indicator';
      loadingDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px 30px;
        border-radius: 8px;
        z-index: 10000;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 10px;
      `;
      loadingDiv.innerHTML = `
        <div style="width: 20px; height: 20px; border: 2px solid #fff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        ${message}
      `;
      document.body.appendChild(loadingDiv);
    }
    
    // Hide loading indicator
    function hideLoadingIndicator() {
      const loadingDiv = document.getElementById('loading-indicator');
      if (loadingDiv) {
        loadingDiv.remove();
      }
    }

    initAuth();

    // Event listeners
    document.getElementById('newChatBtn').addEventListener('click', handleNewChat);
    document.getElementById('userMenu').addEventListener('click', toggleDropdown);
    document.getElementById('logoutBtn').addEventListener('click', handleLogout);
    document.addEventListener('click', closeDropdown);
  </script>
</body>
</html>
